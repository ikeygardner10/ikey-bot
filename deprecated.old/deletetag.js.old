const fs = require('fs');
const utf8 = require('utf8');
const { promisify } = require('util');

module.exports = {
	config: {
		name: 'deletetag',
		aliases: ['dt', 'dtag'],
		usage: '<tag name>',
		cooldown: 8,
		category: 'tag',
		permissions: 'Tag Owner/Server Admin',
		args: true,
		description: '\nDelete a server tag (tag owner or server admin)\nDelete a global tag (tag owner)',
	},
	execute: async (client, message, args) => {

		try {

			const config = client.config;

			const tagname = args[0];
			if(!tagname) return message.channel.send('Name a tag to delete.');
			if(tagname.length > 30) return message.channel.send('Tag name cannot exceed 30 characters');

			let ntn = utf8.encode(tagname);
			ntn = utf8.decode(ntn);
			ntn = ntn.replace(/@everyone/g, '@\u200beveryone');
			ntn = ntn.replace(/@here/g, '@\u200bhere');
			ntn = ntn.replace(/<@&(.*?)>/g, '@\u200brole');
			ntn = ntn.replace(/'/g, '\'\'');
			ntn = ntn.replace(/"/g, '\'\'');

			const cst = 'SELECT * FROM tags WHERE tag = ? AND guildID = ?';
			const cgt = 'SELECT * FROM tags WHERE tag = ? AND guildID IS NULL';
			const dst = 'SET SQL_SAFE_UPDATES = 0; DELETE FROM tags WHERE tag = ? AND guildID = ?';
			const dgt = 'SET SQL_SAFE_UPDATES = 0; DELETE FROM tags WHERE tag = ? AND guildID is NULL';

			client.conPool.getConnection(async (err, connection) => {
				console.info('[DELETE TAG] Connected to database');
				if(err) {
					connection.release();
					console.info('[DELETE TAG] Disconnected from database');
					console.error(`[DELETE TAG] An error occured:\n${err.stack}`);
					return message.channel.send(`**:exclamation: An error occured:**\n\`\`\`${err}\`\`\``);
				}

				const checkServerTag = async () => {
					return new Promise((resolve, reject) => {
						connection.query(cst, [ntn, message.guild.id], async (error, rows) => {
							console.info(`[DELETE TAG] Checking for existing server tag: ${ntn}`);
							if(error) {
								console.error(`[DELETE TAG] An error occured:\n${error.stack}`);
								reject({ message: `**:exclamation: An error occured:**\n\`\`\`${err}\`\`\`` });
							}
							if(rows[0] === undefined) {
								console.info(`[DELETE TAG] No existing server tag found: ${ntn}`);
								checkGlobalTag()
									.then((success) => {
										console.success(`[DELETE TAG] Global tag successfully deleted: ${ntn}`);
										resolve({ message: success.message });
									}).catch((fail) => {
										reject({ message: fail.message });
									});
							} else if (rows[0] !== undefined) {
								console.info(`[DELETE TAG] Existing server tag found: ${ntn}`);
								if(message.author.id !== rows[0].userID && !message.member.hasPermission('ADMINISTRATOR') && message.author.id !== config.ownerID) {
									reject({ message: ':lock: Cannot delete server tag (TAG OWNERS/SERVER ADMINS ONLY)' });
								}
								if(rows[0].imageURL !== null) {
									const imagepath = rows[0].imageURL;
									const unlink = promisify(fs.unlink);
									await unlink(imagepath)
										.then(() => {
											console.success(`[DELETE TAG] Successfully deleted tag ${ntn} image: ${rows[0].imageURL}`);
										}).catch(() => {
											console.info(`[DELETE TAG] Failed to delete tag ${ntn} image: ${rows[0].imageURL}`);
											console.error(`[DELETE TAG] ${error.stack}`);
										});
								}
								deleteServerTag()
									.then((success) => {
										console.success(`[DELETE TAG] Server tag successfully deleted: ${ntn}`);
										resolve({ message: success.message });
									}).catch((fail) => {
										reject({ message: fail.message });
									});
							} else {
								console.info(`[DELETE TAG] No existing tag found: ${ntn}`);
								reject({ message: `:mag: Tag **${ntn}** not found.` });
							}
						});
					});
				};

				const checkGlobalTag = async () => {
					return new Promise((resolve, reject) => {
						connection.query(cgt, [ntn], async (error, rows) => {
							console.info(`[DELETE TAG] Checking for existing server tag: ${ntn}`);
							if(error) {
								console.error(`[DELETE TAG] An error occured:\n${error.stack}`);
								reject({ message: `**:exclamation: An error occured:**\n\`\`\`${err}\`\`\`` });
							}
							if(rows[0] === undefined) {
								console.info(`[DELETE TAG] No existing tag found: ${ntn}`);
								reject({ message: `:mag: Tag **${ntn}** not found.` });
							} else if (rows[0] !== undefined) {
								if(message.author.id !== rows[0].userID && message.author.id !== config.ownerID) reject({ message: ':lock: Cannot delete global tag (TAG OWNER ONLY)' });
								console.info(`[DELETE TAG] Existing global tag found: ${ntn}`);
								if(rows[0].imageURL !== null) {
									const imagepath = rows[0].imageURL;
									const unlink = promisify(fs.unlink);
									await unlink(imagepath)
										.then(() => {
											console.success(`[DELETE TAG] Successfully deleted tag ${ntn} image: ${rows[0].imageURL}`);
										}).catch((err) => {
											console.info(`[DELETE TAG] Failed to delete tag ${ntn} image: ${rows[0].imageURL}`);
											console.error(`[DELETE TAG] ${err.stack}`);
										});
								}
								deleteGlobalTag()
									.then((success) => {
										resolve({ message: success.message });
									}).catch((fail) => {
										reject({ message: fail.message });
									});
							} else {
								console.info(`[DELETE TAG] No existing tag found: ${ntn}`);
								reject({ message: `:mag: Tag **${ntn}** not found.` });
							}
						});
					});
				};

				const deleteGlobalTag = async () => {
					return new Promise((resolve, reject) => {
						console.info(`[DELETE TAG] Deleting global tag: ${ntn}`);
						connection.query(dgt, [ntn], async (error) => {
							if(error) {
								console.error(`[DELETE TAG] An error occured:\n${error.stack}`);
								reject({ message: `**:exclamation: An error occured:**\n\`\`\`${err}\`\`\`` });
							}
							resolve({ message: `:wastebasket: Global tag **${ntn}** deleted` });
						});
					});
				};

				const deleteServerTag = async () => {
					return new Promise((resolve, reject) => {
						console.info(`[DELETE TAG] Deleting server tag: ${ntn}`);
						connection.query(dst, [ntn, message.guild.id], async (error) => {
							if(error) {
								console.error(`[DELETE TAG] An error occured:\n${error.stack}`);
								reject({ message: `**:exclamation: An error occured:**\n\`\`\`${err}\`\`\`` });
							}
							resolve({ message: `:wastebasket: Server tag **${ntn}** deleted` });
						});
					});
				};

				return checkServerTag()
					.then((success) => {
						connection.release();
						console.info('[DELETE TAG] Disconnected from database');
						return message.channel.send(success.message);
					}).catch((fail) => {
						connection.release();
						console.info('[DELETE TAG] Disconnected from database');
						return message.channel.send(fail.message);
					});

			});

		} catch(error) {
			console.error(error.stack);
			return message.channel.send(`\`An error occured:\`\n\`\`\`${error}\`\`\``);
		}
	},
};