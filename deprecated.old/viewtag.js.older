## DEPRECATED BRUH
## THIS WAS A TERRIBLE FIRST ATTEMPT
## SEE THE NEWER COMMAND
## NESTING HELL/AWFUL PROMISES INSIDE ONE ANOTHER

// Grab required modules
const fs = require('fs-extra');

module.exports = {
	// Export command config
	config: {
		name: 'viewtag',
		aliases: ['t', 'vt', 'vtag'],
		usage: '+viewtag <tag name>',
		category: 'tag',
		permissions: 'None',
		description: 'View a tag',
	},
	// Run rest of command
	run: async (client, message, args) => {

		try {

			// Define args[0] as tagname
			const tagname = args[0];

			// Check for tagname and tagname length
			if(!tagname) return message.channel.send('Name a tag to view.');
			if(tagname.length > 30) return message.channel.send('Tag name cannot exceed 30 characters.');

			// String replace/regexp tagname, double single quotes, whitespace @everyone/@here/@role
			let ntn = tagname.replace(/@everyone/g, '@\u200beveryone');
			ntn = ntn.replace(/@here/g, '@\u200bhere');
			ntn = ntn.replace(/<@&(.*?)>/g, '@\u200brole');
			ntn = ntn.replace(/'/g, '\'\'');
			ntn = ntn.replace(/"/g, '\'\'');

			// Define MySQL queries
			const cst = 'SELECT * FROM tags WHERE tag= ? AND guildID= ?';
			const cgt = 'SELECT * FROM tags WHERE tag= ? AND guildID IS NULL';

			// Start function, connect to database, log connection
			client.con.getConnection(function(error, connection) {
				// Catch error, log to console, return error message
				if(error) {
					console.error(error.stack);
					return message.channel.send(`**:exclamation: An error occured:**\n\`\`\`${err}\`\`\``);
				}
				console.log('[VIEW TAG] Connected to database.');

				// Define addTag function
				const viewTag = function() {

					// Return new promise to then resolve or reject later
					return new Promise((resolve, reject) => {

						// Query the database for server tag, then start function
						connection.query(cst, [ntn, message.guild.id], function(error, rows) {
							// Log error, and send error message to channel
							if(error) {
								console.error(error.stack);
								return message.channel.send(`**:exclamation: An error occured:**\n\`\`\`${err}\`\`\``);
							}
							// If rows return defined for server tag check
							if(rows[0] !== undefined) {
								// If imageURL column returns null
								if(rows[0].imageURL === null) {
									// Promise resolve, set log, set message as tag content, log to console, release connection
									resolve({ log: `[VIEW TAG] Server tag viewed: ${ntn}`, message: `${rows[0].content}` },
										console.log(`[VIEW TAG] 1 record found, server tag: ${ntn}`),
										connection.release(),
										console.log('[VIEW TAG] Disconnected from database.'));
								}
								// Else if imageURL returns not null
								else {
									// Define image extension, promise resolve, set log, set message as tag content
									// Attach file, log to console, release connection
									const filepath = rows[0].imageURL;
									const extension = filepath.substring(filepath.lastIndexOf('.'), filepath.length);
									if(!fs.existsSync(filepath)) return message.channel.send(`:paperclip: Server tag **${ntn}** image corrupted.`);
									resolve({ log: `[VIEW TAG] Server tag viewed: ${ntn}`, message: `${rows[0].content}`, files: [{ attachment: filepath, name: ntn + extension }] },
										console.log(`[VIEW TAG] 1 record with image found, server tag: ${ntn}`),
										connection.release(),
										console.log('[VIEW TAG] Disconnected from database.'));
								}
							}
							// Else if rows return undefined for server check
							else {
								// Query MySQL for global tag, then start function
								connection.query(cgt, [ntn], function(error, rowz) {
									// If err, log to console, return error message
									if(error) {
										console.error(error.stack);
										return message.channel.send(`**:exclamation: An error occured:**\n\`\`\`${err}\`\`\``);
									}
									// If rows returns defined for global tag
									if(rowz[0] !== undefined) {
										// If imageURL column returns null
										if(rowz[0].imageURL === null) {
											// Promise resolve, set log, set message as tag content, log to console, release connection
											resolve({ log: `[VIEW TAG] Global tag viewed: ${ntn}`, message: `${rowz[0].content}` },
												console.log(`[VIEW TAG] 1 record found, global tag: ${ntn}`),
												connection.release(),
												console.log('[VIEW TAG] Disconnected from database.'));
										}
										// If imageURL column returns not null
										else {
											// Define image extension, promise resolve, set log, set message as tag content
											// Attach file, log to console, release connection
											const filepath = rowz[0].imageURL;
											const extension = filepath.substring(filepath.lastIndexOf('.'), filepath.length);
											if(!fs.existsSync(filepath)) return message.channel.send(`:paperclip: Global tag **${ntn}** image corrupted.`);
											resolve({ log: `[VIEW TAG] Global tag viewed: ${ntn}`, message: `${rowz[0].content}`, files: [{ attachment: filepath, name: ntn + extension }] },
												console.log(`[VIEW TAG] 1 record with image found, global tag: ${ntn}`),
												connection.release(),
												console.log('[VIEW TAG] Disconnected from database.'));
										}
									}
									// Else if no server tag or global tag found, promise reject, set log, set message
									// Release connection, log to console
									else {
										reject({ log: `[VIEW TAG] Tag ${ntn} not found.`, message: `:mag: Tag **${ntn}** not found.` },
											connection.release(),
											console.log('[ADD TAG] Diconnected from database.'));
									}
								});
							}
						});
					});
				};

				// Run viewTag function defined above, then resolve, log to console, send success message
				// Catch reject, if both server and global tag aren't found, send reject message, log to console
				return viewTag()
					.then((success) => {
						console.log(success.log);
						return message.channel.send(success.message, { files: success.files });
					})
					.catch((fail) => {
						console.error(fail.log);
						return message.channel.send(fail.message);
					});
			});
		}
		// Catch error, log to console, return error message
		catch(error) {
			console.error(error.stack);
			return message.channel.send(`\`An error occured:\`\n\`\`\`${error}\`\`\``);
		}
	},
};